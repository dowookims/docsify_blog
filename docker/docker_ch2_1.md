# 컨테이너 기술과 Docker의 개요

컨테이너 기술을 사용하여 애플리케이션의 실행 환경을 구축 및 운용하기 위한 플랫폼

## 1. 컨테이너 기술 개요

### 컨테이너란 ?

호스트 OS상 논리적인 구획 (컨테이너)을 만들고, 애플리케이션을 작동시키기 위해 필요한 라이브러리나 애플리케이션 등을 하나로 모아 별도의 서버인 것처럼 사용 할 수 있게 만든 것. 호스트 OS의 리소스를 논리적으로 분리시키고, 여러 개의 컨테이너가 공유하여 사용.

컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동하는 것이 특징이다.

> On premises, 물리 서버 상에 설치한 호스트 OS의 경우 하나의 OS에서 여러 애플리 케이션을 운용하며 똑같은 리소스를 사용하기 때문에 오버헤드가 증가한다.
>
> 디렉토리를 공유하고 서버에 설정된 동일한 IP를 사용하며, 미들웨어나 라이브러리를 공유하기에 이를 조심히 활용해야 한다.

> 이에 반해 Container 기술을 사용하면 OS나 디렉토리, IP 주소등 같은 시스템 자원을 각 애플리케이션을 점유하고 있는 것 처럼 활용 할 수 있다.

### 서버 가상화

* 호스트형 서버 가상화

  * 하드웨어 상에 베이스가 되는 호스트 OS를 설치하고, 호스트 OS에 가상화 소프트웨어를 설치한 후 이 가상화 소프트웨어 상 게스트 OS를 작동시키는 기술

    이 방식은 컨테이너와 다르게 호스트 OS상에 게스트 OS를 움직이기에 오버 헤드가 커진다.
    
  * VM VirtualBox, VMware 등

* 하이퍼바이저형 서버 가상화

  * 하드웨어 상 가상화를 전문으로 수행하는 소프트웨어인 하이퍼 바이저를 배치하고 하드웨어와 가상 환경을 제어한다. 호스트 OS 없이 하드웨어를 직접 제어하기 때문에 자원을 효율적으로 사용 할 수 있다. 클라우드 가상 머신에서도 사용하는 방법
  * Microsoft Windows Server의 Hyper-v나  XenServer 등. 가상 환경마다 별도의 OS가 작동하므로 가상 환경의 시작에 걸리는 오버헤드가 커지며, 펌웨어로서 구축하는 경우가 많으며 제품이나 기술에 따라 다양한 방법이 존재한다.

### 도커의 개요

도커는 애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아두고, 그 이미지를 사용하여 다양한 환경에서 애플리케이션 실행 환경을 구축 및 운용하기 위한 오픈소스 플랫폼. 도커는 내부에서 컨테이너 기술을 사용하고 있는 것이 특징이다.

도커에서는 OS, 네트워크 등과 같은 인프라 환경을 컨테이너로 관리하며, 애플리케이션 실행에 필요한 모든 파일 및 디렉토리들을 컨테이너로 모아버린다. 이런 컨테이너 바탕에 Docker 이미지를 Docker Hub와 같은 repository에서 공유한다.

프로그래머는 Docker를 사용하여 개발한 애플리케이션의 실행에 필요한 모든 것이 포함 되어 있는 Docker 이미지를 작성하며, 이 이미지는 컨테이너의 바탕이 됩니다. 작성된 이미지를 바탕으로 컨테이너를 가동시키며, 이 이미지는 Docker가 설치되어 있는 환경이라면 기본적으로 어디서든지 작동되므로, 개발 / 테스트 환경에서는 움직이나 제품 환경에서는 움직이지 않는 , 리스크를 관리 할 수 있는 도구이다.

그리고, 애플리케이션 개발부터 테스트, 제품환경에 대한 전개를 모두 애플리케이션 엔지니어가 수행하는 것이 가능해지므로 지속적 딜리버리를 가능하게 하고, 변화에 강한 시스템을 구축 할 수 있다.

> 이식성(portability)은 한 번 만들면 어디서든지 움직이는 소프트웨어의 특성을 이야기 한다. 도커는 이식성이 높기 때문에 클라우드 시슽스템과의 친화력도 높다. 도커 이미지만 있으면 애플리케이션을 동일한 환경에서 가동 시킬 수 있다. 즉, 개발한 업무 애플리케이션을 온 프레미스 환경에 대한 이전뿐만 아니라 온프레미스 환경 -> 클라우드 -> 온프레미스간에도 시스템 요건이나 예산에 따라 손쉽게 실행 환경을 선택 할 수 있다.

> 시스템 개발에서 애플리케이션의 실행 환경에 제약이 많으면 특정 업체에 의존하는 시스템이 되어버리거나, 개발 속도가 떨어지는 경우가 있다. 실제 온프레미스 환경에서 작동하는 업무 시스템 중에 인프라에 얽매여 필요 이상으로 복잡한 구성으로 시스템을 운용하는 상황에 빠지게 되는데, 비즈니스 속도를 따라갈 수 없는 업무 시스템이 되어버리는 경우도 많다.
>
> 이때 기업은 시스템 유지보수 비용을 계속 부담하면서도 최종 사용자는 시스템 도입에 의한 혜택을 누리기 힘든 상황에 처하게 된다.

#### 1. Docker의 기능

* Docker 이미지를 만드는 기능(Build)
* Docker 이미지를 공유하는 기능(Ship)
* Docker 컨테이너를 작동시키는 기능 (Run)

1) Docker 이미지를 만드는 기능 (Build)

Docker는 애플리케이션의 실행에 필요한 프로그램 본체, 라이브러리, 미들웨어, OS나 네트워크 설정 등을 하나로 모아 Docker 이미지를 만든다. 이 이미지는 하나의 실행환경 에서 움직이는 컨테이너의 바탕이 되며, Docker에서 하나의 이미지에는 하나의 애플리케이션만 넣어두고, 여러 개의 컨테이너를 조합하여 서비스를 구축하는 방법을 권고한다.

Docker 이미지는 애플리케이션의 실행에 필요한 파일들이 저장된 디렉토리이다. Docker 명령을 사용하면 이미지를 tar 파일로 출력 할 수 있다. Docker 이미지는 Docker의 명령을 사용하여 수동으로 만들 수도 있으며, Dockerfile 이라는 설정 파일을 만들어 그것을 바탕으로 자동으로 이미지를 만들 수도 있다. CI, CD 관점에서 코드에 의 한 인프라 관리를 생각하면 DOckerfile을 사용하여 관리하는 것이 바람직 하다 볼 수 있다.

2)  Docker 이미지를 공유하는 기능(Ship)

Docker 이미지는 Docker 레지스트리에서 공유할 수 있다. Docker의 공식 레지스트리인 Docker Hub에서는 Ubuntu, CentOS 등 Linux 배포판의 기본 기능을 제공하는 베이스 이미지를 배포하고 있다. 이런 베이스 이미지에 미들웨어나 라이브러리, 전개할 애플리케이션등을 넣은 이미지를 겹쳐 독자적인 Docker 이미지를 만들어 갈 수 있다.

*Automated Build* : Docker를 Github나 BitBucket등 원격 레포지토리와 연계할 수 있으며, 이 곳에서 Dockerfile을 관리하며 Docker 이미지를 자동 생성하여 Docker hub에 공개하는 경우도 있다.

3) Docker 컨테이너를 작동시키는 기능(Run)

Docker는 Linux 상 컨테이너 단위로 서버 기능을 작동 시킨다. 이 컨테이너의 바탕이 되는 것이 Docker 이미지이다. Docker 이미지만 있으면 Docker가 설치된 환경이라면 어디서든 컨테이너를 작동 시킬 수 있다. 또한 Docker 이미지를 가지고 여러 개의 컨테이너를 가동 시킬 수 있다.

컨테이너의 기동, 정지, 파기는 Docker의 명령을 사용하며 가상화 기술로 서버 기능을 실행시키려면 OS의 실행부터 시작하기에 시간이 걸리나, Docker의 경우 이미 움직이고 있는 OS 상에서 프로세스를 실행시키는 것과 거의 똑같은 속도로 빨리 실행 시킬 수 있다.

Docker는 하나의 Linux 커널을 여러 개의 컨테이너에서 공유하며, 컨테이너 안에서 작동하는 프로세스를 하나의 그룹으로 관리하고, 그룹마다 각각 파일 시스템이나 호스트명, 네트워크 등을 할당하고 있다.  그룹이 다르면 프로세스나 파일에 대한 엑세스를 할 수없다. 이런 구조를 사용하여 컨테이너를 독립된 공간으로서 관리하고 있다. 이를 실행하기 위해 Linux 커널 기능(name space, cgroups) 기술이 사용된다.



제품 환경에서는 모든 Docker Container를 한 대의 Host machine(물리 머신)에서 작동시키는 일은 드물며 시스템의 트래픽 증감이나 가용성 요건, 신뢰도 요건 등을 고려한 후 여러 대의 호스트 머신으로 된 분산 환경을 구축한다. 그리고 보통 컨테이너 관리에 대해서는 Ochestration Tool을 이용하는 것이 일반적이다. Container Ochestration tool은 분산 환경에서 Container를 가동시키기 위해 필요한 기능을 제공한다.



> 시스템 운용 설계의 어려움
>
> 시스템 운용은 해당 시스템의 요건, 시스템의 기술 요소뿐만 아니라 사회적 책무, 유지보수 비용, 운용 멤버의 체제와 기업 풍토등에 의존한다. 그렇기에 기술적 측면만 보고 평가하기는 어렵고 해당 시스템에 적합한 Order made에 가까운 설계가 필요하고, 충분히 숙고하지 않은 운용 방식으로 가동을 하면 생각지 못한 시스템 장애나 보안 사고를 일으킬 수 있다. 그래서 현재 트렌드는 사람이 수작업 하는 것을 최소화 하고, 가능한 자동화 하는 것을 목표로 하고 있다.

> 업무 시스템에서 대규모에 미션 크리티컬한 작업들이 존재하는데, 대규모 시스템의 인프라 구축의 어려움은 시스템간 연계이다. 복잡하게 얽혀 있는 시스템을 안정적으로 가동시키기 위해 높은 기술력 뿐만 아니라 시스템 운용 방법을 숙고해야 한다. 단지 Docker라는 툴만을 맹신하는게 아니라, 사람이나 조직등을 고려한 운용 설계가 필요하다.

#### 2. Docker Component

Docker는 몇 개의 컴포넌트로 구성되며, 핵심 기능이 되는 Docker Engine을 중심으로 컴포넌트를 조합하여 애플리케이션 실행 환경을 구축한다.  Docker는 CLI에서 조작하는게 핵심이다.

* Dokcer Engine(Docker의 핵심 기능)
  * Docker의 이미지를 생성하고, 컨테이너를 기동시키기 위한 Docker의 핵심 기능. Docker ㅁ여령의 실행이나 Dockerfile에 의한 이미지도 생성
* Docker Registry (이미지 공개 및 공유)
  * 컨테이너 바탕이 되는 Docker 이미지 공개 및 공유하기 위한 레지스트리 기능. DockerHub도 이를 사용
* Docker Compose(컨테이너 일원 관리)
  * 여러 개의 Container 구성 정보를 코드로 정의하고, 명령을 실행함으로써 애플리케이션의 실행 환경을 구성하는 컨테이너들을 일원 관리하기 위한 툴
* Docker Machine (Docker  실행 환경 구축)
  * 로컬 호스트용인 VirtualBox를 비롯, AWS나 Azure등 클라우드 환경에 Docker 실행 환경을 명령으로 자동 생성하기 위한 툴
* Docker Swarm(클러스터 관리)
  * Docker Host를 클러스터화하기 위한 툴. Docker Swarm에서 클러스터를 관리하거나 API를 제공하는 역할은 Manager가, Docker Container를 실행하는 역할은 Node, 또한 Open source인 Kubernetes도 이용 가능하다.

**상호운용성(Interoperability)** : 다양한 조직이나 시스템과 연계하여 사용할 수 있는 소프트웨어의 특성



#### 3. Docker Operating Structure

Docker는 Linx 커널 기술이 Base로 되어 있다.

#### 1) Name space

Docker는 Container를 만들어 독립된 환경을 만들고, 이를 구획화하여 애플리케이션의 실행 환경을 만든다. 이 컨테이너를 구획하는 기술은 Linux 커널의namespace라는 기능을 사용하고 있다.

namespace는 한 덩어리의 데이터에 anming 하여 분할함으로 충돌 가능성을 줄이고, 쉽게 참조할 수 있게 하는 개념이다. 이름과 연결된 실체는 그 이름이 어떤 namespace에 속해 있는지 고유하게 정ㅇ해진다. 그래서 namespace가 다르면 동일한 이름이라도 다른 실체로 처리된다.

Linux 커널의 namespace기능은 Linux Object에 이름을 붙임으로 다음과 같은 6개의 독립된 환경을 구축할 수 있다.

* PID namespace  : ProcessID Name space
* Network namespace: Network Device, IP address, port number, Routing Table, Filtering table 등과 같은 Network resource를 격리도니 namespace마다 독립적으로 가질 수 있다.
* UID namespace : UserID namespace :  사용자 ID, 그룹 ID를 namespace별로 독립적으로 가지게 한다. namespace안과 호스트 OS 상 UID/GID가 서로 연결되어 namespace 안과 밖에 서로 다른 UID /GID를 가질 수 있다. 
* MOUNT namespace: Linux에서 파일 시스템을 사용하기 위해 mount가 필요하다. mount는 컴퓨터에 연결된 기기나 기억장치를 OS에 인식시켜 이용 가능한 상태로 만드는 것. MOUNT namespace는 마운트 조작을 하면 namespace안에 격리된 파일 시스템 트리를 만든다. 다른 namespace 기능과 마찬가지로 namespace 안에서 수행한 마우느트는 호스트 OS나 다른 namespace에 접근하지 못하게 된다.
* UTS namespace : namespace 별로 호스팅명이나 도메인명을 독자적으로 가질 수 있다.
* IPC namespace: 프로세스간 통신 오브젝트를 namespace 별로 독립적으로 가질 수 있다. IPC는 System V  프로세스간 통신 Object라 하는 공유 메모리나 세마포어 / 메시지 큐를 말한다.
  * 세마포어 : 프로세스가 요구하는 자원 관리에 이용되는 배타제어 장치
  * 메시지 큐 : 프로세스간 비동기 통신 시 사용되는 Queuing 장치

#### 2) cgroups : 릴리스 관리 장치

Docker에서는 물리 머신 상의 자원을 여러 컨테이너가 공유하여 작동한다. 이때 Linux 커널 기능인 control groups(cgroups) 기능을 사용하여 자원의 할당 등을 관리한다. Linux에서는 프로그램을 프로세스로서 실행하며 cgroups는 프로세스와 스레드를 그룹화하여 그룹 안에 존재하는 프로세스와 스레드에 대한 관리를 수행하기 위한 기능이다. 주요 서비스스템으로

* cpu : CPU 사용량 제한
* cpuacct : CPU 사용량 통계 정보 제공
* cpuset : CPU나 메모리 배치 제어
* memory : 메모리나 스왑 사용량 제한
* devices: 디바이스에 대한 액세스 허가 / 거부
* freezer: 그룹에 속한 프로세스 정지 / 재개
* net_cls : 네트워크 제어 태그 부가
* blkio : 블록 디바이스 입출력량 제어

#### 3) 네트워크 구성(가상 브리지 / 가상 NIC)

Linux Docker 설치 시 서버의 물리 NIC가 docker0 이라는 가상 브리지 네트워크로 연결된다. docker0은 Docker를 실행시킨 후 디폴트로 만들어진다. Docker 컨테이너가 실행되면 172.17.0.0/16이라는 subnet mask를 가진 IP주소가 eth0으로 자동 할당된다. 이 가상 NIC는 OSI 참조 모델의 레이어 2인 가상 네트워크 인터페이스로 , NIC와 터널링 통신을 한다.

Docker Container와 외부 Network 가 통신을 하 ㄹ때 가상 브리지 docker0과 호스트 OS의 물리 NIC에서 패킷을 전송하는 장치가 필요한데, Docker에선느 NAPT 기능을 사용하여 연결된다. NAPT란 Network Address Port Translation란 하나의 IP주소를 여러 컴퓨터가 공유하는 기술로 IP 주소와 포트 번호를 변환하는 기능이다. Private IP 주소와 글로벌 IP 주소를 투과적으로 상호 변환하는 기술로 TCP / IP 포트 번호까지 동적으로 변환하기에 하나의 글로벌 IP 주소로 여러 대의 머신이 동시에 연결할 수 있다. DOcker에서는 NAPT 에 Linux의 iptables 를사용한다.

Docker에서 이 기능을 사용할 때 Container 시작 시 Container 안에서 사용하는 가상 브리지인 docker0에 대해 개방한다. 